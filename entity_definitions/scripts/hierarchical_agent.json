{
    "template_id": "script_hierarchical_agent",
    "name": "Hierarchical Task Orchestrator",
    "description": "Decomposes complex tasks and delegates to specialized sub-agents",
    "entity_type": "agent",
    "agent_type": "hierarchical",
    "category": "orchestration",
    "difficulty": "advanced",
    "icon": "bi-diagram-3",
    "tags": [
        "agent",
        "hierarchical",
        "orchestration",
        "delegation"
    ],
    "use_count": 0,
    "script_content": "\"\"\"\nHierarchical Task Orchestrator - Python Script Mode\n====================================================\nBreaks down tasks and delegates to sub-agents.\n\"\"\"\n\nfrom typing import Dict, List, Any, Optional\nfrom dataclasses import dataclass, field\nfrom enum import Enum\nfrom abc import ABC, abstractmethod\nimport uuid\n\n\nclass TaskStatus(Enum):\n    PENDING = \"pending\"\n    RUNNING = \"running\"\n    COMPLETED = \"completed\"\n    FAILED = \"failed\"\n\n\nclass AgentCapability(Enum):\n    RESEARCH = \"research\"\n    ANALYSIS = \"analysis\"\n    WRITING = \"writing\"\n    CODING = \"coding\"\n    REVIEW = \"review\"\n\n\n@dataclass\nclass Task:\n    task_id: str\n    description: str\n    capability: AgentCapability\n    status: TaskStatus = TaskStatus.PENDING\n    result: Any = None\n    \n    @classmethod\n    def create(cls, desc: str, cap: AgentCapability) -> 'Task':\n        return cls(str(uuid.uuid4())[:8], desc, cap)\n    \n    def to_dict(self) -> Dict[str, Any]:\n        return {\n            \"task_id\": self.task_id,\n            \"description\": self.description,\n            \"capability\": self.capability.value,\n            \"status\": self.status.value,\n            \"result\": str(self.result)[:100] if self.result else None\n        }\n\n\n@dataclass\nclass ExecutionResult:\n    task_id: str\n    success: bool\n    output: Any\n    agent_name: str\n    \n    def to_dict(self) -> Dict[str, Any]:\n        return {\n            \"task_id\": self.task_id,\n            \"success\": self.success,\n            \"agent\": self.agent_name,\n            \"output\": str(self.output)[:200]\n        }\n\n\nclass SubAgent(ABC):\n    def __init__(self, name: str, capability: AgentCapability):\n        self.name = name\n        self.capability = capability\n        self.tasks_done = 0\n    \n    @abstractmethod\n    def execute(self, task: Task) -> ExecutionResult:\n        pass\n    \n    def can_handle(self, task: Task) -> bool:\n        return task.capability == self.capability\n\n\nclass ResearchAgent(SubAgent):\n    def __init__(self):\n        super().__init__(\"Researcher\", AgentCapability.RESEARCH)\n    \n    def execute(self, task: Task) -> ExecutionResult:\n        self.tasks_done += 1\n        return ExecutionResult(task.task_id, True, f\"Research: {task.description}\", self.name)\n\n\nclass AnalysisAgent(SubAgent):\n    def __init__(self):\n        super().__init__(\"Analyst\", AgentCapability.ANALYSIS)\n    \n    def execute(self, task: Task) -> ExecutionResult:\n        self.tasks_done += 1\n        return ExecutionResult(task.task_id, True, f\"Analysis: {task.description}\", self.name)\n\n\nclass WritingAgent(SubAgent):\n    def __init__(self):\n        super().__init__(\"Writer\", AgentCapability.WRITING)\n    \n    def execute(self, task: Task) -> ExecutionResult:\n        self.tasks_done += 1\n        return ExecutionResult(task.task_id, True, f\"Writing: {task.description}\", self.name)\n\n\nclass CodingAgent(SubAgent):\n    def __init__(self):\n        super().__init__(\"Coder\", AgentCapability.CODING)\n    \n    def execute(self, task: Task) -> ExecutionResult:\n        self.tasks_done += 1\n        return ExecutionResult(task.task_id, True, f\"Code: {task.description}\", self.name)\n\n\nclass ReviewAgent(SubAgent):\n    def __init__(self):\n        super().__init__(\"Reviewer\", AgentCapability.REVIEW)\n    \n    def execute(self, task: Task) -> ExecutionResult:\n        self.tasks_done += 1\n        return ExecutionResult(task.task_id, True, f\"Review: {task.description}\", self.name)\n\n\nclass TaskOrchestrator:\n    def __init__(self):\n        self.agents = [\n            ResearchAgent(), AnalysisAgent(), WritingAgent(),\n            CodingAgent(), ReviewAgent()\n        ]\n        self.tasks: Dict[str, Task] = {}\n        self.results: Dict[str, ExecutionResult] = {}\n    \n    def decompose_task(self, description: str) -> List[Task]:\n        tasks = []\n        keywords = description.lower()\n        \n        if any(w in keywords for w in [\"research\", \"find\", \"search\"]):\n            tasks.append(Task.create(f\"Research: {description}\", AgentCapability.RESEARCH))\n        if any(w in keywords for w in [\"analyze\", \"evaluate\"]):\n            tasks.append(Task.create(f\"Analyze: {description}\", AgentCapability.ANALYSIS))\n        if any(w in keywords for w in [\"write\", \"create\", \"draft\"]):\n            tasks.append(Task.create(f\"Write: {description}\", AgentCapability.WRITING))\n        if any(w in keywords for w in [\"code\", \"implement\"]):\n            tasks.append(Task.create(f\"Code: {description}\", AgentCapability.CODING))\n        \n        tasks.append(Task.create(f\"Review: {description}\", AgentCapability.REVIEW))\n        \n        for task in tasks:\n            self.tasks[task.task_id] = task\n        return tasks\n    \n    def find_agent(self, task: Task) -> Optional[SubAgent]:\n        for agent in self.agents:\n            if agent.can_handle(task):\n                return agent\n        return None\n    \n    def execute_task(self, task: Task) -> ExecutionResult:\n        agent = self.find_agent(task)\n        if not agent:\n            return ExecutionResult(task.task_id, False, \"No agent\", \"None\")\n        \n        task.status = TaskStatus.RUNNING\n        result = agent.execute(task)\n        task.status = TaskStatus.COMPLETED if result.success else TaskStatus.FAILED\n        task.result = result.output\n        self.results[task.task_id] = result\n        return result\n    \n    def execute_all(self, tasks: List[Task]) -> List[ExecutionResult]:\n        return [self.execute_task(t) for t in tasks]\n    \n    def aggregate(self, results: List[ExecutionResult]) -> Dict[str, Any]:\n        return {\n            \"total\": len(results),\n            \"successful\": len([r for r in results if r.success]),\n            \"outputs\": [r.to_dict() for r in results]\n        }\n\n\nSYSTEM_PROMPT = \"\"\"You are a hierarchical task orchestrator.\n1. Decompose complex tasks\n2. Assign to specialized agents\n3. Execute and aggregate results\n\"\"\"\n\norchestrator = TaskOrchestrator()\n\nagent = {\n    \"name\": \"Hierarchical Task Orchestrator\",\n    \"description\": \"Decomposes and delegates tasks\",\n    \"agent_type\": \"hierarchical\",\n    \"version\": \"1.0.0\",\n    \"system_prompt\": SYSTEM_PROMPT,\n    \"tools\": [\"decompose\", \"delegate\", \"aggregate\"],\n    \"llm_config\": {\n        \"provider\": \"ollama\",\n        \"model\": \"llama3.2:3b\",\n        \"temperature\": 0.3\n    },\n    \"orchestration_config\": {\n        \"max_parallel\": 3,\n        \"timeout_seconds\": 300\n    },\n    \"tags\": [\"hierarchical\", \"orchestration\", \"python-script\"],\n    \"category\": \"orchestration\"\n}\n\n__export__ = agent\n\n\ndef execute(input_data: Dict[str, Any]) -> Dict[str, Any]:\n    desc = input_data.get(\"prompt\", input_data.get(\"task\", \"\"))\n    tasks = orchestrator.decompose_task(desc)\n    results = orchestrator.execute_all(tasks)\n    aggregated = orchestrator.aggregate(results)\n    \n    return {\n        \"success\": aggregated[\"successful\"] == aggregated[\"total\"],\n        \"response\": f\"Completed {aggregated['successful']}/{aggregated['total']} tasks\",\n        \"result\": aggregated,\n        \"tasks\": [t.to_dict() for t in tasks]\n    }\n\n\ndef validate() -> tuple:\n    if not orchestrator.agents:\n        return False, \"No sub-agents configured\"\n    return True, \"Hierarchical Agent configuration is valid\"\n"
}